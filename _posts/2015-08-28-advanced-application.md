---
layout: post
date: '2015-08-28T18:05:00+01:00'
---

<h2 id="advanced-application">Advanced application</h2>
<p>For now, we have no architecture. Our application is a simple Irrlicht application, processing user input, rendering graphics based on physics state of our in-game world and being totally unscallable.</p>
<p>Let's change the way the things go. Let's change the <strong>architecture</strong>! By the name or Refactoring!..</p>
<p>To tell the truth, I do not like refactoring my projects (unless I'm at work). I like totally rewriting them! It's the best way to learn something (as for me). If the project is not too ibg, it's better to write everything from beginning - you'll notice all the defects at your architecture during this creepy process.</p>
<p><strong>So, the architecture for our application is:</strong></p>
<ol>
<li>the <strong>Core</strong> is something like server - it takes the <strong>messages</strong> from scripts and <strong>handles</strong> them, bypassing to other scripts; also, it reads the application <strong>configuration</strong> and runs the scripts described at config (at startup); the main application loop is just <strong>processing all the scripts and their messages</strong> plus <strong>rendering</strong></li>
<li><strong>Script</strong> is being run each application tick and process the <strong>world events</strong>, which are generated by other scripts during their runtime</li>
</ol>
<h3 id="first-lua-scripted-c-application">First Lua-scripted C++ application</h3>
<p>Let's write one small application which will call some Lua script function and react to the Lua script function call. It will be the most simple scripted application you could imagine!</p>
<p>Here's the <strong>C++</strong> part:</p>

{% highlight cpp %}
#include <lua.hpp>
#include <iostream>

using namespace std;

int someServerHandler(lua_State  *l)
{
    int argc = lua_gettop(l);

    for (int i = 0; i < argc; i++)
    {
        cout << "ARG[" << i + 1 << "] = " << lua_tostring(l, i + 1) << endl;
    }

    lua_pushstring(l, "m_pi");
    lua_pop(l, argc - 1);
    //lua_pushnumber(l, 3.14);

    return argc;
}

int main()
{
    lua_State *l = lua_open();
    luaL_openlibs(l);

    lua_register(l, "someScriptEvent", someServerHandler);

    luaL_dofile(l, "script.lua");

    lua_getglobal(l, "someScriptHandler");

    if (!lua_isfunction(l, -1))
    {
            lua_pop(l, 1);
            cout << "Could not find function someScriptHandler" << endl;
    } else
    {
            lua_pushstring(l, "event_argument");

            // 1 argument, 0 results, 0 WAT?
            lua_pcall(l, 1, 0, 0);
    }

    lua_close(l);

    return 0;
}
{% endhighlight %}

<p>And here is our little script:</p>

{% highlight lua %}
function someScriptHandler(x)
    print("someScriptHandler("..x..")");
end

res = someScriptEvent("hello", "world");

print(someScriptEvent());

for k, v in res do
    print(k.." = "..v);
end
{% endhighlight %}

<p>That's it! Here what we've done: we created a C++ application which runs <code>script.lua</code> file and calls its function <code>someScriptHandler()</code>. And whenever script calls the <code>someScriptEvent()</code> function, our C++ application reacts calling its <code>someServerHandler()</code> function.</p>
<p>Hey! We have just written our first scripted server! Although, it does nothing useful, it's a real scripted application! Now we are cool guys and could proceed creating an AAA-games' compete!</p>
