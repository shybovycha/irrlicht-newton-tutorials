<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Adding Some Newtonality</title>
  <meta name="description" content="Adding some NewtonianityCompiling Newton SDK under LinuxWriting this part took me a long time. Well, this story is very short, but I faced an unbreakable wal...">

  <link rel="stylesheet" href="/irrlicht-newton-tutorials//css/main.css">
  <link rel="canonical" href="http://shybovycha.github.io/irrlicht-newton-tutorials//irrlicht-newton-tutorials//2015/08/28/adding-some-newtonality.html">
  <link rel="alternate" type="application/rss+xml" title="Irrlicht Newton Tutorials" href="http://shybovycha.github.io/irrlicht-newton-tutorials//irrlicht-newton-tutorials//feed.xml" />

  <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/2.0.2/jquery.min.js"></script>
  <script type="text/javascript" src="/irrlicht-newton-tutorials//js/bootstrap.min.js"></script>
</head>


  <body>
    <div class="container-fluid wrapper">
      <div class="box">
        <div class="row">
          <div class="column col-sm-3" id="sidebar">
            <a class="logo" href="/">G</a>



<ul class="nav">
  
    <li >
      <a href="/2015/08/28/introduction.html">Introduction</a>
    </li>
  
    <li >
      <a href="/2015/08/28/irrlicht-basics.html">Irrlicht Basics</a>
    </li>
  
    <li >
      <a href="/2015/08/28/first-application.html">First Application</a>
    </li>
  
    <li class="active">
      <a href="/2015/08/28/adding-some-newtonality.html">Adding Some Newtonality</a>
    </li>
  
    <li >
      <a href="/2015/08/28/advanced-application.html">Advanced Application</a>
    </li>
  
</ul>

<div class="hidden-xs" id="sidebar-footer">
  <footer class="site-footer">
  <div class="row">
    <div class="col-sm-6 text-center">
      
      <a class="btn btn-info" href="https://github.com/shybovycha">
          <span class="icon  icon--github">
            <svg viewBox="0 0 16 16" style="width: 16px; height: 16px;">
              <path fill="#818181" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
            </svg>
          </span>

          shybovycha
      </a>
      
    </div>

    <div class="col-sm-6 text-center">
      
      <a class="btn btn-info" href="https://twitter.com/shybovycha">
          <span class="icon  icon--twitter">
            <svg viewBox="0 0 16 16" style="width: 16px; height: 16px;">
              <path fill="#818181" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
              c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
            </svg>
          </span>

          <span class="username">shybovycha</span>
      </a>
      
    </div>
  </div>
</footer>

</div>

          </div>

          <div class="column col-sm-9" id="main">
            <div class="row">
  <h2 id="adding-some-newtonianity">Adding some Newtonianity</h2>
<h3 id="compiling-newton-sdk-under-linux">Compiling Newton SDK under Linux</h3>
<p>Writing this part took me a long time. Well, this story is very short, but I faced an unbreakable wall - misunderstanting...</p>
<p>So, the essence of the whole paragraph is just three steps:</p>
<ol>
<li>Download Newton 3.0.8+ SDK and unpack it somewhere on your PC</li>
<li>
<p>Open your terminal, navigate to the directory where you've unpacked Newton SDK and run this:</p>
<pre><code>cd coreLibrary_300/projects/posix64 &amp;&amp; make
</code></pre>
</li>
<li>
<p>Now just copy the library to your <code>/usr/lib</code> directory:</p>
<pre><code>sudo cp *.so /usr/lib/
</code></pre>
</li>
</ol>
<h3>Compoling under Windows</h3>
<p>There are some tricks under this platform. For Newton 3.10 particulally. The first trick is the large amount of similar directories
with sources and projects. And you could be scared when first taking a look over. Just follow these instructions and you shall not be lost!
</p>
<ol>
    <li>Unpack the downloaded archive somewhere, let's say <i>NEWTON_HOME</i></li>
    <li>Navigate to the <pre>NEWTON_HOME/packages/projects/visualStudio_2008</pre> <i>(replace 2008 with the VS version you have installed)</i></li>
    <li>Run the <strong>build.sln</strong> file <i>(will be opened in the VS)</i></li>
    <li>Sequently, choose <b>DebugDLL</b> and when done <b>ReleaseDLL</b> build mode and press <b>Build</b></li>
    <li>Perform the same build steps for <pre>newton.sln</pre> file at <pre>NEWTON_HOME/coreLibrary_300/projects/windows/project_vs2008/</pre> directory</li>
</ol>
<p>By default, libraries and DLLs are built to... not very handy places. So we shall add few extra steps to make a life easier:</p>
<ol>
    <li>Create a directory <pre>NEWTON_HOME/lib</pre></li>
    <li>Copy all the <pre>*.lib</pre> and <pre>*.dll</pre> files from <pre>NEWTON_HOME/packages/projects/visualStudio_2008/Win32/</pre> dir to <pre>NEWTON_HOME/lib</pre></li>
    <li>Perform the same copying pattern for files within the <pre>NEWTON_HOME/coreLibrary_300/projects/windows/project_vs2008/Win32/</pre> directory</li>
    <li>Set your IDE to take the library files from <pre>NEWTON_HOME/lib</pre> firectory <i>(for my VS2008 Express and lower that is <b>Tools [Top Menu] -&gt; Options... -&gt; Projects and solutions [left folder] -&gt; VC++ Directories [sub-folder] -&gt; Library files [right top dropdown]</b>)</i></li>
</ol>
<p>And you are ready to proceed with our first Newton- and Irrlicht-powered application!</p>
<h3 id="the-first-attempt">The first attempt</h3>
<p>Let's start modifying our Irrlicht sample application. First of all, we shall add some Newton headers:</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include&lt;dMathDefines.h&gt;</span>
<span class="cp">#include&lt;dVector.h&gt;</span>
<span class="cp">#include&lt;dQuaternion.h&gt;</span>
<span class="cp">#include&lt;dMatrix.h&gt;</span>
<span class="cp">#include&lt;Newton.h&gt;</span></code></pre></div>

<p>These will include all the data structures and functions we shall use.</p>
<p>And here goes the first Newton call function:</p>
<pre><code>NewtonSetMemorySystem(AllocMemory, FreeMemory);
</code></pre>
<p>Add this right after Irrlicht initialization. And all the code below (except the <em>Newton world stepping</em> and <em>function definitions</em>) shall be added after this line.</p>
<p>One sets the way Newton shall manage objects in memory. If you want to define your cool way to serve memory allocation and freement - just define that logic within those two methods. But for now we shall use the <code>stdlib</code> methods:</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span><span class="o">*</span> <span class="nf">AllocMemory</span><span class="p">(</span><span class="kt">int</span> <span class="n">sizeInBytes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeInBytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">FreeMemory</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sizeInBytes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>Then, we create a Newton world. This is a virtual space where all the magic is done. It shall contain all our mesh' (<em>visual part of The Entity</em>) bodies (<em>invisible physical part of The Entity</em>).</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">NewtonWorld</span><span class="o">*</span> <span class="n">g_world</span> <span class="o">=</span> <span class="n">NewtonCreate</span><span class="p">();</span>
<span class="n">NewtonSetSolverModel</span><span class="p">(</span><span class="n">g_world</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></div>

<p>Solver is the way Newton performs calculations. That is just a configuration option. Yet, important one.</p>
<p>Now, let's create our first Entity! Remember the Sphere node, we created with Irrlicht? We shall now add some magic to make it act like a metal ball!</p>
<p>First of all, let's remember how we created our Sphere mesh:</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">scene</span><span class="o">::</span><span class="n">ISceneNode</span> <span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">addSphereSceneNode</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">core</span><span class="o">::</span><span class="n">vector3df</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">));</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">setMaterialTexture</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">getTexture</span><span class="p">(</span><span class="s">&quot;../media/wall.bmp&quot;</span><span class="p">));</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">setMaterialFlag</span><span class="p">(</span><span class="n">video</span><span class="o">::</span><span class="n">EMF_LIGHTING</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p><strong>Note:</strong> do not forget to copy Irrlicht <code>/media</code> directory to the parent directory for the tutorial sample!</p>
<p>Now just add these lines right after the Sphere' mesh creation code:</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">dMatrix</span> <span class="nf">offset</span><span class="p">(</span><span class="n">GetIdentityMatrix</span><span class="p">());</span>
<span class="n">NewtonCollision</span><span class="o">*</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">NewtonCreateSphere</span><span class="p">(</span><span class="n">g_world</span><span class="p">,</span> <span class="mf">10.f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>

<span class="n">NewtonBody</span><span class="o">*</span> <span class="n">body</span> <span class="o">=</span> <span class="n">NewtonCreateDynamicBody</span><span class="p">(</span><span class="n">g_world</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>

<span class="n">NewtonBodySetUserData</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

<span class="n">dVector</span> <span class="n">origin</span><span class="p">;</span>
<span class="n">dVector</span> <span class="n">inertia</span><span class="p">;</span>
<span class="n">NewtonConvexCollisionCalculateInertialMatrix</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inertia</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="kt">float</span> <span class="n">mass</span> <span class="o">=</span> <span class="mf">16.f</span><span class="p">;</span>
<span class="n">NewtonBodySetMassMatrix</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">mass</span> <span class="o">*</span> <span class="n">inertia</span><span class="p">.</span><span class="n">m_x</span><span class="p">,</span> <span class="n">mass</span> <span class="o">*</span> <span class="n">inertia</span><span class="p">.</span><span class="n">m_y</span><span class="p">,</span> <span class="n">mass</span> <span class="o">*</span> <span class="n">inertia</span><span class="p">.</span><span class="n">m_z</span><span class="p">);</span>

<span class="n">NewtonBodySetCentreOfMass</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="kt">float</span> <span class="n">mass</span> <span class="o">=</span> <span class="mf">16.f</span><span class="p">;</span>
<span class="n">NewtonBodySetMassProperties</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">shape</span><span class="p">);</span>

<span class="n">NewtonBodySetMaterialGroupID</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">NewtonBodySetForceAndTorqueCallback</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">ApplyGravity</span><span class="p">);</span>

<span class="n">NewtonBodySetTransformCallback</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">SetTransformCallback</span><span class="p">);</span></code></pre></div>

<p>And define two functions, <code>SetTransformCallback</code> and <code>ApplyGravity</code>:</p>
<pre><code>void SetTransformCallback (const NewtonBody* body, const dFloat* matrix, int threadIndex)
{
    scene::ISceneNode* node;

    // Get the position from the matrix
    dVector position(matrix[12], matrix[13], matrix[14], 1.0f);
    dQuaternion rotation;

    NewtonBodyGetRotation(body, &amp;rotation.m_q0);

    // get the entity associated with this rigid body
    node = (scene::ISceneNode*) NewtonBodyGetUserData(body);

    core::vector3df node_position = core::vector3df(position[0], position[1], position[2]);

    // transform Newtonian rotation to Irrlicht rotation
    core::quaternion tmp_quaternion = core::quaternion(rotation.m_q0, rotation.m_q1, rotation.m_q2, rotation.m_q3);
    core::vector3df tmp_rotation;
    tmp_quaternion.toEuler(tmp_rotation);
    core::vector3df node_rotation(core::radToDeg(tmp_rotation.X), core::radToDeg(tmp_rotation.Y), core::radToDeg(tmp_rotation.Z));

    node-&gt;setPosition(node_position);
    node-&gt;setRotation(node_rotation);
}

void ApplyGravity(const NewtonBody* body, dFloat timestep, int threadIndex)
{
    dFloat Ixx, Iyy, Izz, mass;
    NewtonBodyGetMassMatrix(body, &amp;mass, &amp;Ixx, &amp;Iyy, &amp;Izz);
    dVector force(0.f, -9.8 * mass, 0.f);
    NewtonBodySetForce(body, &amp;force.m_x);
}
</code></pre>
<p>First of them synchronizes Irrlicht meshes with their Newtonian bodies. The second one Applies some default forces and torques to bodies.</p>
<p>And the last step is Newton stepping. It shall tell Newton: <em>Hey! You! Just update my physics! Now!</em> And all the magic shall be performed.</p>
<p>You should end up with the code like this:</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/** Example 004 Movement</span>

<span class="cm">This Tutorial shows how to move and animate SceneNodes. The</span>
<span class="cm">basic concept of SceneNodeAnimators is shown as well as manual</span>
<span class="cm">movement of nodes using the keyboard.  We&#39;ll demonstrate framerate</span>
<span class="cm">independent movement, which means moving by an amount dependent</span>
<span class="cm">on the duration of the last run of the Irrlicht loop.</span>

<span class="cm">Example 19.MouseAndJoystick shows how to handle those kinds of input.</span>

<span class="cm">As always, I include the header files, use the irr namespace,</span>
<span class="cm">and tell the linker to link with the .lib file.</span>
<span class="cm">*/</span>
<span class="cp">#ifdef _MSC_VER</span>
<span class="c1">// We&#39;ll also define this to stop MSVC complaining about sprintf().</span>
<span class="cp">#define _CRT_SECURE_NO_WARNINGS</span>
<span class="cp">#pragma comment(lib, &quot;Irrlicht.lib&quot;)</span>
<span class="cp">#pragma comment(lib, &quot;Newton.lib&quot;)</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;irrlicht.h&gt;</span>

<span class="cp">#include &lt;dMathDefines.h&gt;</span>
<span class="cp">#include &lt;dVector.h&gt;</span>
<span class="cp">#include &lt;dQuaternion.h&gt;</span>
<span class="cp">#include &lt;dMatrix.h&gt;</span>
<span class="cp">#include &lt;Newton.h&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">irr</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">To receive events like mouse and keyboard input, or GUI events like &quot;the OK</span>
<span class="cm">button has been clicked&quot;, we need an object which is derived from the</span>
<span class="cm">irr::IEventReceiver object. There is only one method to override:</span>
<span class="cm">irr::IEventReceiver::OnEvent(). This method will be called by the engine once</span>
<span class="cm">when an event happens. What we really want to know is whether a key is being</span>
<span class="cm">held down, and so we will remember the current state of each key.</span>
<span class="cm">*/</span>
<span class="k">class</span> <span class="nc">MyEventReceiver</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEventReceiver</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// This is the one method that we have to implement</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">OnEvent</span><span class="p">(</span><span class="k">const</span> <span class="n">SEvent</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Remember whether each key is down or up</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">EventType</span> <span class="o">==</span> <span class="n">irr</span><span class="o">::</span><span class="n">EET_KEY_INPUT_EVENT</span><span class="p">)</span>
            <span class="n">KeyIsDown</span><span class="p">[</span><span class="n">event</span><span class="p">.</span><span class="n">KeyInput</span><span class="p">.</span><span class="n">Key</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">.</span><span class="n">KeyInput</span><span class="p">.</span><span class="n">PressedDown</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// This is used to check whether a key is being held down</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">IsKeyDown</span><span class="p">(</span><span class="n">EKEY_CODE</span> <span class="n">keyCode</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">KeyIsDown</span><span class="p">[</span><span class="n">keyCode</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">MyEventReceiver</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">KEY_KEY_CODES_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">KeyIsDown</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="c1">// We use this array to store the current state of each key</span>
    <span class="kt">bool</span> <span class="n">KeyIsDown</span><span class="p">[</span><span class="n">KEY_KEY_CODES_COUNT</span><span class="p">];</span>
<span class="p">};</span>

<span class="c1">// this is the call back for allocation newton memory</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">AllocMemory</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sizeInBytes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">sizeInBytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// this is the callback for freeing Newton Memory</span>
<span class="kt">void</span> <span class="nf">FreeMemory</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sizeInBytes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">free</span> <span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Transform callback to set the matrix of a the visual entity</span>
<span class="kt">void</span> <span class="nf">SetTransformCallback</span> <span class="p">(</span><span class="k">const</span> <span class="n">NewtonBody</span><span class="o">*</span> <span class="n">body</span><span class="p">,</span> <span class="k">const</span> <span class="n">dFloat</span><span class="o">*</span> <span class="n">matrix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threadIndex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">scene</span><span class="o">::</span><span class="n">ISceneNode</span><span class="o">*</span> <span class="n">node</span><span class="p">;</span>

    <span class="c1">// Get the position from the matrix</span>
    <span class="n">dVector</span> <span class="n">position</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="mf">1.0f</span><span class="p">);</span>
    <span class="n">dQuaternion</span> <span class="n">rotation</span><span class="p">;</span>

    <span class="c1">// we will ignore the Rotation part of matrix and use the quaternion rotation stored in the body</span>
    <span class="n">NewtonBodyGetRotation</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rotation</span><span class="p">.</span><span class="n">m_q0</span><span class="p">);</span>

    <span class="c1">// get the entity associated with this rigid body</span>
    <span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">scene</span><span class="o">::</span><span class="n">ISceneNode</span><span class="o">*</span><span class="p">)</span> <span class="n">NewtonBodyGetUserData</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>

    <span class="n">core</span><span class="o">::</span><span class="n">vector3df</span> <span class="n">node_position</span> <span class="o">=</span> <span class="n">core</span><span class="o">::</span><span class="n">vector3df</span><span class="p">(</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

    <span class="n">core</span><span class="o">::</span><span class="n">quaternion</span> <span class="n">tmp_quaternion</span> <span class="o">=</span> <span class="n">core</span><span class="o">::</span><span class="n">quaternion</span><span class="p">(</span><span class="n">rotation</span><span class="p">.</span><span class="n">m_q0</span><span class="p">,</span> <span class="n">rotation</span><span class="p">.</span><span class="n">m_q1</span><span class="p">,</span> <span class="n">rotation</span><span class="p">.</span><span class="n">m_q2</span><span class="p">,</span> <span class="n">rotation</span><span class="p">.</span><span class="n">m_q3</span><span class="p">);</span>
    <span class="n">core</span><span class="o">::</span><span class="n">vector3df</span> <span class="n">tmp_rotation</span><span class="p">;</span>
    <span class="n">tmp_quaternion</span><span class="p">.</span><span class="n">toEuler</span><span class="p">(</span><span class="n">tmp_rotation</span><span class="p">);</span>
    <span class="n">core</span><span class="o">::</span><span class="n">vector3df</span> <span class="n">node_rotation</span><span class="p">(</span><span class="n">core</span><span class="o">::</span><span class="n">radToDeg</span><span class="p">(</span><span class="n">tmp_rotation</span><span class="p">.</span><span class="n">X</span><span class="p">),</span> <span class="n">core</span><span class="o">::</span><span class="n">radToDeg</span><span class="p">(</span><span class="n">tmp_rotation</span><span class="p">.</span><span class="n">Y</span><span class="p">),</span> <span class="n">core</span><span class="o">::</span><span class="n">radToDeg</span><span class="p">(</span><span class="n">tmp_rotation</span><span class="p">.</span><span class="n">Z</span><span class="p">));</span>

    <span class="c1">// since this tutorial run the physics and a different fps than the Graphics</span>
    <span class="c1">// we need to save the entity current transformation state before updating the new state.</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">node_position</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">setRotation</span><span class="p">(</span><span class="n">node_rotation</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ApplyGravity</span><span class="p">(</span><span class="k">const</span> <span class="n">NewtonBody</span><span class="o">*</span> <span class="n">body</span><span class="p">,</span> <span class="n">dFloat</span> <span class="n">timestep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threadIndex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">dFloat</span> <span class="n">Ixx</span><span class="p">,</span> <span class="n">Iyy</span><span class="p">,</span> <span class="n">Izz</span><span class="p">,</span> <span class="n">mass</span><span class="p">;</span>
    <span class="n">NewtonBodyGetMassMatrix</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mass</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Ixx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Iyy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Izz</span><span class="p">);</span>
    <span class="n">dVector</span> <span class="n">force</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.8</span> <span class="o">*</span> <span class="n">mass</span><span class="p">,</span> <span class="mf">0.f</span><span class="p">);</span>
    <span class="n">NewtonBodySetForce</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">force</span><span class="p">.</span><span class="n">m_x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">The event receiver for keeping the pressed keys is ready, the actual responses</span>
<span class="cm">will be made inside the render loop, right before drawing the scene. So lets</span>
<span class="cm">just create an irr::IrrlichtDevice and the scene node we want to move. We also</span>
<span class="cm">create some other additional scene nodes, to show that there are also some</span>
<span class="cm">different possibilities to move and animate scene nodes.</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// create device</span>
    <span class="n">MyEventReceiver</span> <span class="n">receiver</span><span class="p">;</span>

    <span class="n">IrrlichtDevice</span><span class="o">*</span> <span class="n">device</span> <span class="o">=</span> <span class="n">createDevice</span><span class="p">(</span><span class="n">irr</span><span class="o">::</span><span class="n">video</span><span class="o">::</span><span class="n">EDT_OPENGL</span><span class="p">,</span>
            <span class="n">core</span><span class="o">::</span><span class="n">dimension2d</span><span class="o">&lt;</span><span class="n">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">16</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">receiver</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// could not create selected driver.</span>

    <span class="n">video</span><span class="o">::</span><span class="n">IVideoDriver</span><span class="o">*</span> <span class="n">driver</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">getVideoDriver</span><span class="p">();</span>
    <span class="n">scene</span><span class="o">::</span><span class="n">ISceneManager</span><span class="o">*</span> <span class="n">smgr</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">getSceneManager</span><span class="p">();</span>

    <span class="cm">/*</span>
<span class="cm">    Create the node which will be moved with the WSAD keys. We create a</span>
<span class="cm">    sphere node, which is a built-in geometry primitive. We place the node</span>
<span class="cm">    at (0,0,30) and assign a texture to it to let it look a little bit more</span>
<span class="cm">    interesting. Because we have no dynamic lights in this scene we disable</span>
<span class="cm">    lighting for each model (otherwise the models would be black).</span>
<span class="cm">    */</span>
    <span class="n">scene</span><span class="o">::</span><span class="n">ISceneNode</span> <span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">addSphereSceneNode</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">core</span><span class="o">::</span><span class="n">vector3df</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">));</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">setMaterialTexture</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">getTexture</span><span class="p">(</span><span class="s">&quot;../media/wall.bmp&quot;</span><span class="p">));</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">setMaterialFlag</span><span class="p">(</span><span class="n">video</span><span class="o">::</span><span class="n">EMF_LIGHTING</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">NewtonSetMemorySystem</span> <span class="p">(</span><span class="n">AllocMemory</span><span class="p">,</span> <span class="n">FreeMemory</span><span class="p">);</span>

    <span class="c1">// create the Newton World</span>
    <span class="n">NewtonWorld</span><span class="o">*</span> <span class="n">g_world</span> <span class="o">=</span> <span class="n">NewtonCreate</span> <span class="p">();</span>

    <span class="c1">// use the standard x87 floating point model</span>
    <span class="c1">// NewtonSetPlatformArchitecture (g_world, 0);</span>

    <span class="n">NewtonSetSolverModel</span> <span class="p">(</span><span class="n">g_world</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">dMatrix</span> <span class="n">offset</span><span class="p">(</span><span class="n">GetIdentityMatrix</span><span class="p">());</span>
    <span class="n">NewtonCollision</span><span class="o">*</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">NewtonCreateSphere</span><span class="p">(</span><span class="n">g_world</span><span class="p">,</span> <span class="mf">10.f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>

    <span class="n">NewtonBody</span><span class="o">*</span> <span class="n">body</span> <span class="o">=</span> <span class="n">NewtonCreateDynamicBody</span><span class="p">(</span><span class="n">g_world</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>

    <span class="n">NewtonBodySetUserData</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

    <span class="cm">/*//dMatrix matrix(node-&gt;getRotation(), ent-&gt;m_curPosition);</span>
<span class="cm">    //NewtonBodySetMatrix (body, &amp;matrix[0][0]);</span>

<span class="cm">    dVector origin;</span>
<span class="cm">    dVector inertia;</span>
<span class="cm">    NewtonConvexCollisionCalculateInertialMatrix(shape, &amp;inertia[0], &amp;origin[0]);</span>

<span class="cm">    float mass = 16.f;</span>
<span class="cm">    NewtonBodySetMassMatrix(body, mass, mass * inertia.m_x, mass * inertia.m_y, mass * inertia.m_z);</span>

<span class="cm">    NewtonBodySetCentreOfMass(body, &amp;origin[0]);*/</span>

    <span class="kt">float</span> <span class="n">mass</span> <span class="o">=</span> <span class="mf">16.f</span><span class="p">;</span>
    <span class="n">NewtonBodySetMassProperties</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">shape</span><span class="p">);</span>

    <span class="n">NewtonBodySetMaterialGroupID</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">NewtonBodySetForceAndTorqueCallback</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">ApplyGravity</span><span class="p">);</span>

    <span class="n">NewtonBodySetTransformCallback</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">SetTransformCallback</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">    To be able to look at and move around in this scene, we create a first</span>
<span class="cm">    person shooter style camera and make the mouse cursor invisible.</span>
<span class="cm">    */</span>
    <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">addCameraSceneNodeFPS</span><span class="p">();</span>
    <span class="n">device</span><span class="o">-&gt;</span><span class="n">getCursorControl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">    Add a colorful irrlicht logo</span>
<span class="cm">    */</span>
    <span class="n">device</span><span class="o">-&gt;</span><span class="n">getGUIEnvironment</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addImage</span><span class="p">(</span>
        <span class="n">driver</span><span class="o">-&gt;</span><span class="n">getTexture</span><span class="p">(</span><span class="s">&quot;../media/irrlichtlogoalpha2.tga&quot;</span><span class="p">),</span>
        <span class="n">core</span><span class="o">::</span><span class="n">position2d</span><span class="o">&lt;</span><span class="n">s32</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">));</span>

    <span class="cm">/*</span>
<span class="cm">    And one for Newton GD</span>
<span class="cm">    */</span>
    <span class="n">device</span><span class="o">-&gt;</span><span class="n">getGUIEnvironment</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addImage</span><span class="p">(</span>
        <span class="n">driver</span><span class="o">-&gt;</span><span class="n">getTexture</span><span class="p">(</span><span class="s">&quot;../media/newton_logo.png&quot;</span><span class="p">),</span>
        <span class="n">core</span><span class="o">::</span><span class="n">position2d</span><span class="o">&lt;</span><span class="n">s32</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">130</span><span class="p">));</span>

    <span class="n">gui</span><span class="o">::</span><span class="n">IGUIStaticText</span><span class="o">*</span> <span class="n">diagnostics</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">getGUIEnvironment</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addStaticText</span><span class="p">(</span>
        <span class="s">L&quot;&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">::</span><span class="n">rect</span><span class="o">&lt;</span><span class="n">s32</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
    <span class="n">diagnostics</span><span class="o">-&gt;</span><span class="n">setOverrideColor</span><span class="p">(</span><span class="n">video</span><span class="o">::</span><span class="n">SColor</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="cm">/*</span>
<span class="cm">    We have done everything, so lets draw it. We also write the current</span>
<span class="cm">    frames per second and the name of the driver to the caption of the</span>
<span class="cm">    window.</span>
<span class="cm">    */</span>
    <span class="kt">int</span> <span class="n">lastFPS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// In order to do framerate independent movement, we have to know</span>
    <span class="c1">// how long it was since the last frame</span>
    <span class="n">u32</span> <span class="n">then</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">getTimer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getTime</span><span class="p">();</span>

    <span class="c1">// This is the movemen speed in units per second.</span>
    <span class="k">const</span> <span class="n">f32</span> <span class="n">MOVEMENT_SPEED</span> <span class="o">=</span> <span class="mf">5.f</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// Work out a frame delta time.</span>
        <span class="k">const</span> <span class="n">u32</span> <span class="n">now</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">getTimer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getTime</span><span class="p">();</span>
        <span class="k">const</span> <span class="n">f32</span> <span class="n">frameDeltaTime</span> <span class="o">=</span> <span class="p">(</span><span class="n">f32</span><span class="p">)(</span><span class="n">now</span> <span class="o">-</span> <span class="n">then</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.f</span><span class="p">;</span> <span class="c1">// Time in seconds</span>
        <span class="n">then</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

        <span class="n">driver</span><span class="o">-&gt;</span><span class="n">beginScene</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">video</span><span class="o">::</span><span class="n">SColor</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">113</span><span class="p">,</span><span class="mi">113</span><span class="p">,</span><span class="mi">133</span><span class="p">));</span>

        <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">drawAll</span><span class="p">();</span> <span class="c1">// draw the 3d scene</span>
        <span class="n">device</span><span class="o">-&gt;</span><span class="n">getGUIEnvironment</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">drawAll</span><span class="p">();</span> <span class="c1">// draw the gui environment (the logo)</span>

        <span class="n">driver</span><span class="o">-&gt;</span><span class="n">endScene</span><span class="p">();</span>

        <span class="kt">int</span> <span class="n">fps</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">getFPS</span><span class="p">();</span>

        <span class="n">NewtonUpdate</span> <span class="p">(</span><span class="n">g_world</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0f</span> <span class="o">/</span> <span class="n">fps</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lastFPS</span> <span class="o">!=</span> <span class="n">fps</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">core</span><span class="o">::</span><span class="n">stringw</span> <span class="n">tmp</span><span class="p">(</span><span class="s">L&quot;Newton + Irrlicht Tutorial 01 [&quot;</span><span class="p">);</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">();</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="s">L&quot;] fps: &quot;</span><span class="p">;</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="n">fps</span><span class="p">;</span>

            <span class="n">device</span><span class="o">-&gt;</span><span class="n">setWindowCaption</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
            <span class="n">lastFPS</span> <span class="o">=</span> <span class="n">fps</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">    In the end, delete the Irrlicht device.</span>
<span class="cm">    */</span>
    <span class="n">device</span><span class="o">-&gt;</span><span class="n">drop</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">That&#39;s it. Compile and play around with the program.</span>
<span class="cm">**/</span></code></pre></div>

<p>Let's compile it and run!</p>
<p><i>Linux build command:</i></p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">g++ main.cpp -I/home/user/newton-3.0.8/packages/posix64/ -L/home/user/newton-3.0.8/packages/posix64/ -I/home/user/newton-3.0.8/packages/dMath/ -I/home/user/irrlicht-1.8/include/ -L /home/user/irrlicht-1.8/lib/Linux/ -lNewton -lIrrlicht -lGL -o tuorial01</code></pre></div>

<p><strong>Hint:</strong> to make simulation slower and so watch ball falling in detail, make the <i>NewtonUpdate</i> FPS argument even smaller. A thousand times, say.</p>
<p><strong>Note:</strong> I used the home directory for user named <em>user</em> to store Newton SDK and Irrlicht SDK. You may want to change this!</p>
<p>If you did everything right, you shall see the metal ball falling right through the camera and down... down... down...</p>


  <div class="row">
    <div class="col-sm-12">
      <span class="label label-primary">Aug 28, 2015</span>
      
      
    </div>
  </div>
</div>

          </div>
        </div>
      </div>
    </div>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42282809-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>
</html>
